# Some custom sort
- sort field in struct
- Example code:
```go
package main

import (
	"fmt"
	"sort"
)

type Person struct {
	First string
	Age   int
}

type ByAge []Person

// Implementing the sort.Interface
func (bn ByAge) Len() int           { return len(bn) }
func (bn ByAge) Less(i, j int) bool { return bn[i].Age < bn[j].Age }
func (bn ByAge) Swap(i, j int)      { bn[i], bn[j] = bn[j], bn[i] }

func main() {
	p1 := Person{
		First: "John",
		Age:   30,
	}

	p2 := Person{
		First: "Jane",
		Age:   25,
	}

	p3 := Person{
		First: "Doe",
		Age:   40,
	}

	// Creating a slice of Person
	// and initializing it with the Person instances
	people := []Person{p1, p2, p3}

	// Sorting the slice of Person by First name
	// using the sort package
	fmt.Println(people)
	sort.Sort(ByAge(people))
	fmt.Println("Sorted by Age:")
	fmt.Println(people)
}

```

Output:

```
[{John 30} {Jane 25} {Doe 40}]
Sorted by Age:
[{Jane 25} {John 30} {Doe 40}]
```

# Explain:
Đoạn code này sử dụng gói `sort` trong Go để sắp xếp một slice của `Person` theo **tuổi (Age)**. Để hiểu cách nó hoạt động, mình sẽ giải thích từng phần:

### 1. **Cơ chế sắp xếp của `sort.Sort`**
Gói `sort` trong Go yêu cầu một kiểu dữ liệu muốn sắp xếp phải triển khai giao diện `sort.Interface`, bao gồm 3 phương thức:
- `Len() int`: Trả về độ dài của tập hợp dữ liệu (số phần tử trong slice).
- `Less(i, j int) bool`: So sánh hai phần tử tại vị trí `i` và `j`, trả về `true` nếu phần tử tại `i` nhỏ hơn phần tử tại `j` (quy định thứ tự).
- `Swap(i, j int)`: Hoán đổi hai phần tử tại vị trí `i` và `j`.

Trong code của bạn, kiểu `ByAge` (là một alias của `[]Person`) đã triển khai 3 phương thức này, cho phép `sort.Sort` biết cách sắp xếp slice `people`.

### 2. **Vai trò của từng hàm**
- **`Len() int`**:
  - Trả về số lượng phần tử trong slice `ByAge` (tức `len(bn)`).
  - Hàm này giúp `sort.Sort` biết kích thước của dữ liệu để duyệt qua các phần tử.
  - Không liên quan trực tiếp đến logic sắp xếp, chỉ cung cấp thông tin về số lượng.

- **`Less(i, j int) bool`**:
  - Đây là hàm **quan trọng nhất** vì nó định nghĩa **logic so sánh**.
  - Trong trường hợp này, `Less(i, j)` trả về `true` nếu `bn[i].Age < bn[j].Age`, nghĩa là phần tử tại `i` có tuổi nhỏ hơn phần tử tại `j`.
  - Điều này dẫn đến việc `sort.Sort` sẽ sắp xếp slice theo **thứ tự tăng dần** dựa trên tuổi (`Age`).
  - Nếu bạn muốn sắp xếp giảm dần, bạn có thể đổi thành `bn[i].Age > bn[j].Age`.

- **`Swap(i, j int)`**:
  - Hàm này hoán đổi hai phần tử tại vị trí `i` và `j` trong slice.
  - Nó được `sort.Sort` gọi khi cần thay đổi vị trí các phần tử để đạt được thứ tự mong muốn.
  - Hàm này cũng không liên quan trực tiếp đến logic so sánh, mà chỉ hỗ trợ việc di chuyển phần tử.

### 3. **Thuật toán sắp xếp**
- Gói `sort` của Go sử dụng một phiên bản tối ưu của **quicksort** kết hợp với **insertion sort** cho các tập hợp nhỏ (thường dưới 10 phần tử) và **heapsort** trong một số trường hợp đặc biệt để đảm bảo hiệu suất.
- Thuật toán cụ thể không phụ thuộc vào code của bạn, mà được triển khai trong gói `sort`. Code của bạn chỉ cần cung cấp cách **so sánh** (`Less`) và cách **hoán đổi** (`Swap`).

### 4. **Kết quả của code**
- Ban đầu, slice `people` chứa:
  ```
  [{John 30} {Jane 25} {Doe 40}]
  ```
- Sau khi gọi `sort.Sort(ByAge(people))`, slice được sắp xếp theo **tuổi tăng dần**:
  ```
  Sorted by Age:
  [{Jane 25} {John 30} {Doe 40}]
  ```
- Lý do: `Less(i, j)` quy định rằng phần tử có `Age` nhỏ hơn sẽ được đặt trước.

### 5. **Tóm lại**
- **Cách sắp xếp**: Sắp xếp **tăng dần** theo trường `Age` của struct `Person`.
- **Hàm quan trọng**: `Less(i, j)` quyết định logic so sánh (`Age` nhỏ hơn đứng trước).
- **Len và Swap**: Chỉ hỗ trợ cung cấp kích thước và hoán đổi phần tử, không ảnh hưởng trực tiếp đến cách so sánh.
- Nếu bạn muốn đổi cách sắp xếp (ví dụ: giảm dần hoặc theo `First`), chỉ cần sửa hàm `Less`.

Nếu bạn cần giải thích thêm hoặc muốn thử sắp xếp theo cách khác (ví dụ: theo `First`), cứ hỏi nhé!