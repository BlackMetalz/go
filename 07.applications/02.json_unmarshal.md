# Theory
- Json can represent 4 primitive types: strings, numbers, booleans, and null.
- A name is a string, value is a string, number, boolean and null, object or array.
- Good tool: json to go https://mholt.github.io/json-to-go/
- The encoding of each struct field can be customized by the format string stored under the "json" key in the struct field's tag. Example:
```
// Field appears in JSON as key "myName"
Field int `json:"myName"`
```
- The "omitempty" option specifies that the field should be ommited from the object if its value is empty
- byte is an alias for uint8

# Explain for omitempty
ƒê√∫ng r·ªìi bro! Trong Go, khi s·ª≠ d·ª•ng tag `json:"fieldName,omitempty"` trong struct, n√≥ c√≥ nghƒ©a l√† n·∫øu gi√° tr·ªã c·ªßa field ƒë√≥ l√† **"empty"** (t√πy thu·ªôc v√†o ki·ªÉu d·ªØ li·ªáu), th√¨ field ƒë√≥ s·∫Ω **kh√¥ng ƒë∆∞·ª£c ƒë∆∞a v√†o JSON** khi m√£ h√≥a (marshal) struct th√†nh JSON. 

C·ª• th·ªÉ, c√°c gi√° tr·ªã ƒë∆∞·ª£c coi l√† "empty" bao g·ªìm:
- `nil` (cho pointer, slice, map, channel, interface)
- `0` (cho s·ªë nguy√™n, s·ªë th·ª±c)
- `""` (chu·ªói r·ªóng)
- `false` (cho boolean)
- Slice ho·∫∑c map r·ªóng (`[]` ho·∫∑c `map[]`)

### V√≠ d·ª•:
```go
package main

import (
	"encoding/json"
	"fmt"
)

type User struct {
	Name  string `json:"name,omitempty"`
	Age   int    `json:"age,omitempty"`
	Email string `json:"email,omitempty"`
}

func main() {
	user := User{
		Name:  "John",
		Age:   0,        // empty
		Email: "",       // empty
	}

	jsonData, _ := json.Marshal(user)
	fmt.Println(string(jsonData))
}
```

**Output:**
```json
{"name":"John"}
```

### Gi·∫£i th√≠ch:
- Field `Name` c√≥ gi√° tr·ªã `"John"`, n√™n xu·∫•t hi·ªán trong JSON.
- Field `Age` c√≥ gi√° tr·ªã `0` (empty), n√™n b·ªã b·ªè qua.
- Field `Email` l√† chu·ªói r·ªóng `""` (empty), n√™n c≈©ng b·ªã b·ªè qua.

N·∫øu kh√¥ng c√≥ `omitempty`, th√¨ c√°c field v·ªõi gi√° tr·ªã empty v·∫´n s·∫Ω xu·∫•t hi·ªán trong JSON, v√≠ d·ª•: `{"name":"John","age":0,"email":""}`.

V·∫≠y t√≥m l·∫°i, `omitempty` gi√∫p JSON g·ªçn h∆°n b·∫±ng c√°ch lo·∫°i b·ªè c√°c field c√≥ gi√° tr·ªã empty. Hi·ªÉu ƒë√∫ng ch∆∞a bro? üòé

# Explain for tag `json:"-"`
Nice question, bro! üòé Trong Go, khi s·ª≠ d·ª•ng tag `json:"-"` trong struct, n√≥ c√≥ nghƒ©a l√† **field ƒë√≥ s·∫Ω b·ªã b·ªè qua ho√†n to√†n** khi m√£ h√≥a (marshal) ho·∫∑c gi·∫£i m√£ (unmarshal) JSON, **b·∫•t k·ªÉ gi√° tr·ªã c·ªßa field ƒë√≥ l√† g√¨** (empty hay kh√¥ng empty).

### √ù nghƒ©a c·ªßa `json:"-"`:
- Field v·ªõi tag `json:"-"` **kh√¥ng xu·∫•t hi·ªán** trong JSON output khi marshal.
- Khi unmarshal JSON v√†o struct, d·ªØ li·ªáu t·ª´ JSON cho field n√†y (n·∫øu c√≥) s·∫Ω **b·ªã b·ªè qua**, v√† gi√° tr·ªã c·ªßa field trong struct kh√¥ng b·ªã ·∫£nh h∆∞·ªüng.
- N√≥ kh√°c v·ªõi `omitempty`, v√¨ `omitempty` ch·ªâ b·ªè field khi gi√° tr·ªã empty, c√≤n `json:"-"` b·ªè field **lu√¥n**.

### V√≠ d·ª•:
```go
package main

import (
	"encoding/json"
	"fmt"
)

type User struct {
	Name     string `json:"name"`
	Age      int    `json:"age"`
	Password string `json:"-"` // B·ªè qua field n√†y
}

func main() {
	// T·∫°o struct
	user := User{
		Name:     "John",
		Age:      30,
		Password: "secret123", // C√≥ gi√° tr·ªã nh∆∞ng s·∫Ω b·ªã b·ªè qua
	}

	// Marshal th√†nh JSON
	jsonData, _ := json.Marshal(user)
	fmt.Println("JSON output:", string(jsonData))

	// Unmarshal JSON v√†o struct
	jsonInput := []byte(`{"name":"Alice","age":25,"password":"hacked"}`)
	var newUser User
	json.Unmarshal(jsonInput, &newUser)
	fmt.Printf("Unmarshaled struct: %+v\n", newUser)
}
```

**Output:**
```
JSON output: {"name":"John","age":30}
Unmarshaled struct: {Name:Alice Age:25 Password:}
```

### Gi·∫£i th√≠ch:
1. **Marshal (struct ‚Üí JSON):**
   - Field `Password` c√≥ tag `json:"-"`, n√™n d√π c√≥ gi√° tr·ªã `"secret123"`, n√≥ **kh√¥ng xu·∫•t hi·ªán** trong JSON output.
   - Ch·ªâ `Name` v√† `Age` ƒë∆∞·ª£c ƒë∆∞a v√†o JSON.

2. **Unmarshal (JSON ‚Üí struct):**
   - JSON input c√≥ field `"password":"hacked"`, nh∆∞ng v√¨ `Password` c√≥ tag `json:"-"`, gi√° tr·ªã n√†y **b·ªã b·ªè qua**.
   - Field `Password` trong struct `newUser` v·∫´n gi·ªØ gi√° tr·ªã m·∫∑c ƒë·ªãnh (chu·ªói r·ªóng `""` trong tr∆∞·ªùng h·ª£p n√†y).

### Khi n√†o d√πng `json:"-"`?
- Khi b·∫°n mu·ªën m·ªôt field trong struct ch·ªâ d√πng n·ªôi b·ªô (internal) v√† kh√¥ng mu·ªën n√≥ xu·∫•t hi·ªán trong JSON (v√≠ d·ª•: m·∫≠t kh·∫©u, th√¥ng tin nh·∫°y c·∫£m).
- Khi JSON input c√≥ field m√† b·∫°n kh√¥ng mu·ªën map v√†o struct.

T√≥m l·∫°i, `json:"-"` l√† c√°ch ƒë·ªÉ "·∫©n" ho√†n to√†n m·ªôt field kh·ªèi qu√° tr√¨nh x·ª≠ l√Ω JSON. Hi·ªÉu ch∆∞a bro? C√≥ c·∫ßn th√™m v√≠ d·ª• n√†o n·ªØa kh√¥ng? üòÑ

# Explain for tag json
ƒê√∫ng r·ªìi bro! üòé Trong Go, khi b·∫°n s·ª≠ d·ª•ng tag `json:"..."` trong struct, t√™n field trong JSON output s·∫Ω **ph·ª• thu·ªôc v√†o gi√° tr·ªã c·ªßa tag `json`**, ch·ª© kh√¥ng ph·∫£i t√™n field trong struct. H√£y ƒë·ªÉ m√¨nh gi·∫£i th√≠ch r√µ h∆°n v√† x√°c nh·∫≠n v√≠ d·ª• c·ªßa b·∫°n.

### 1. Gi·∫£i th√≠ch c∆° b·∫£n
- Tag `json:"First"` trong struct ƒë·ªãnh nghƒ©a r·∫±ng field ƒë√≥ s·∫Ω ƒë∆∞·ª£c bi·ªÉu di·ªÖn v·ªõi t√™n `"First"` trong JSON (khi marshal) v√† s·∫Ω √°nh x·∫° t·ª´ key `"First"` trong JSON (khi unmarshal).
- N·∫øu b·∫°n ƒë·ªïi tag, v√≠ d·ª• t·ª´ `json:"First"` th√†nh `json:"theFirst"`, th√¨ trong JSON output, field ƒë√≥ s·∫Ω xu·∫•t hi·ªán v·ªõi t√™n m·ªõi l√† `"theFirst"`, b·∫•t k·ªÉ t√™n field trong struct l√† g√¨ (`First`, `Last`, hay b·∫•t k·ª≥ t√™n n√†o).

### 2. V·ªõi struct ban ƒë·∫ßu
```go
type AutoGenerated struct {
	First string `json:"First"`
	Last  string `json:"Last"`
	Age   int    `json:"Age"`
}
```

Khi b·∫°n marshal m·ªôt instance c·ªßa struct n√†y th√†nh JSON, c√°c field s·∫Ω ƒë∆∞·ª£c ƒë·∫∑t t√™n theo tag `json`. V√≠ d·ª•:

```go
package main

import (
	"encoding/json"
	"fmt"
)

type AutoGenerated struct {
	First string `json:"First"`
	Last  string `json:"Last"`
	Age   int    `json:"Age"`
}

func main() {
	data := AutoGenerated{
		First: "John",
		Last:  "Doe",
		Age:   30,
	}

	jsonData, _ := json.Marshal(data)
	fmt.Println(string(jsonData))
}
```

**Output:**
```json
{"First":"John","Last":"Doe","Age":30}
```

### 3. Khi ƒë·ªïi tag th√†nh `json:"theFirst"`
N·∫øu b·∫°n ƒë·ªïi tag c·ªßa field `First` t·ª´ `json:"First"` th√†nh `json:"theFirst"`, struct s·∫Ω nh∆∞ sau:

```go
type AutoGenerated struct {
	First string `json:"theFirst"` // Tag thay ƒë·ªïi
	Last  string `json:"Last"`
	Age   int    `json:"Age"`
}
```

Gi·ªù khi marshal, JSON output s·∫Ω ph·∫£n √°nh t√™n m·ªõi trong tag:

```go
package main

import (
	"encoding/json"
	"fmt"
)

type AutoGenerated struct {
	First string `json:"theFirst"`
	Last  string `json:"Last"`
	Age   int    `json:"Age"`
}

func main() {
	data := AutoGenerated{
		First: "John",
		Last:  "Doe",
		Age:   30,
	}

	jsonData, _ := json.Marshal(data)
	fmt.Println(string(jsonData))
}
```

**Output:**
```json
{"theFirst":"John","Last":"Doe","Age":30}
```

Nh∆∞ b·∫°n d·ª± ƒëo√°n, field `First` trong struct gi·ªù ƒë∆∞·ª£c bi·ªÉu di·ªÖn l√† `"theFirst"` trong JSON, v·ªõi gi√° tr·ªã t∆∞∆°ng ·ª©ng (v√≠ d·ª• `"John"`).

### 4. L∆∞u √Ω th√™m
- **T√™n field trong struct kh√¥ng quan tr·ªçng**: T√™n field trong struct (nh∆∞ `First`, `Last`) ch·ªâ d√πng trong code Go. Trong JSON, t√™n ƒë∆∞·ª£c l·∫•y t·ª´ tag `json:"..."`.
- **Case-sensitive**: Tag `json:"theFirst"` v√† `json:"TheFirst"` s·∫Ω t·∫°o ra c√°c key kh√°c nhau trong JSON.
- **N·∫øu kh√¥ng c√≥ tag**: N·∫øu b·∫°n kh√¥ng khai b√°o tag `json`, t√™n field trong JSON s·∫Ω m·∫∑c ƒë·ªãnh l√† t√™n field trong struct, v√≠ d·ª•:
  ```go
  type AutoGenerated struct {
      First string // Kh√¥ng c√≥ tag
      Last  string `json:"Last"`
  }
  ```
  JSON output s·∫Ω l√†: `{"First":"John","Last":"Doe"}`.

### 5. K·∫øt lu·∫≠n
- ƒê√∫ng nh∆∞ b·∫°n n√≥i, n·∫øu ƒë·ªïi `json:"First"` th√†nh `json:"theFirst"`, JSON output s·∫Ω c√≥ key `"theFirst"` thay v√¨ `"First"`.
- Output s·∫Ω ki·ªÉu:
  ```json
  {"theFirst":"value abc","Last":"Doe","Age":30}
  ```
  (gi·∫£ s·ª≠ `First` c√≥ gi√° tr·ªã `"value abc"`).

Hi·ªÉu r√µ ch∆∞a bro? üòÑ C√≥ mu·ªën m√¨nh th·ª≠ th√™m v√≠ d·ª• n√†o kh√°c, v√≠ d·ª• nh∆∞ unmarshal JSON v·ªõi tag m·ªõi ho·∫∑c k·∫øt h·ª£p `omitempty` kh√¥ng?

# Code example
```go
package main

import (
	"fmt"
	"encoding/json"
)

// Need to uppercase the first letter of the struct fields to export them.
// This is necessary for the 'json.Marshal' function to work correctly.
// The 'json.Marshal' function requires the fields to be exported in order to serialize them into JSON format.
// If the fields are not exported, they will not be included in the JSON output.
type person struct {
	First string
	Last  string
	Age int
}

func main() {
	dataString := `[{"First":"Kien","Last":"Luong","Age":33},{"First":"Black","Last":"Metal","Age":33}]`
	// Init byte slice
	// Convert the JSON string to a byte slice
	data := []byte(dataString)

	// Unmarshal the JSON string into a slice of person structs
	// Init a slice of person structs
	var people []person
	// Unmarshal the JSON string into the slice of person structs
	// The 'json.Unmarshal' function takes the byte slice and a pointer to the slice of person structs
	err := json.Unmarshal(data, &people)
	if err != nil {
		// If there is an error, print it and return
		fmt.Println("Error:", err)
		return
	}

	// All data of the JSON string is now in the slice of person structs
	// Print the JSON string
	fmt.Println("JSON string:", people)

	// Print the slice of person structs
	for i, v := range people {
		fmt.Println("People number", i)
		fmt.Println(v.First, v.Last, v.Age)
	}
}
```

Output:
``` 
JSON string: [{Kien Luong 33} {Black Metal 33}]
People number 0
Kien Luong 33
People number 1
Black Metal 33
```