# Code with and without wg.Add(2).
```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// computeSumOfSquares calculates the sum of squares for a given slice of numbers
func computeSumOfSquares(numbers []int, name string) int64 {
	var sum int64
	for _, num := range numbers {
		sum += int64(num) * int64(num)
	}
	fmt.Printf("%s completed, sum of squares: %d\n", name, sum)
	return sum
}

func main() {
	// Create two large slices of numbers for computation
	numbers1 := make([]int, 1000000)
	numbers2 := make([]int, 1000000)
	for i := range numbers1 {
		numbers1[i] = i
		numbers2[i] = i + 1
	}

	// ---- Sequential Execution (No Goroutines) ----
	fmt.Println("Running sequentially (no goroutines)...")
	start := time.Now()

	computeSumOfSquares(numbers1, "Task 1")
	computeSumOfSquares(numbers2, "Task 2")

	sequentialDuration := time.Since(start)
	fmt.Printf("Sequential execution took: %v\n\n", sequentialDuration)

	// ---- Concurrent Execution (With Goroutines) ----
	fmt.Println("Running concurrently (with goroutines)...")
	var wg sync.WaitGroup
	start = time.Now()

	wg.Add(2) // Wait for 2 goroutines

	// Run Task 1 in a goroutine
	go func() {
		computeSumOfSquares(numbers1, "Task 1 (goroutine)")
		wg.Done()
	}()

	// Run Task 2 in a goroutine
	go func() {
		computeSumOfSquares(numbers2, "Task 2 (goroutine)")
		wg.Done()
	}()

	wg.Wait() // Wait for both goroutines to finish
	concurrentDuration := time.Since(start)
	fmt.Printf("Concurrent execution took: %v\n", concurrentDuration)

	// Compare the durations
	fmt.Printf("\nTime saved with goroutines: %v\n", sequentialDuration-concurrentDuration)
}
```

Output:
```
Running sequentially (no goroutines)...
Task 1 completed, sum of squares: 333332833333500000
Task 2 completed, sum of squares: 333333833333500000
Sequential execution took: 1.660133ms

Running concurrently (with goroutines)...
Task 1 (goroutine) completed, sum of squares: 333332833333500000
Task 2 (goroutine) completed, sum of squares: 333333833333500000
Concurrent execution took: 852.671¬µs

Time saved with goroutines: 807.462¬µs
```

# Explaination from Grok!
M√¨nh s·∫Ω t·∫°o m·ªôt ƒëo·∫°n code Go s·ª≠ d·ª•ng `wg.Add(2)` ƒë·ªÉ ch·∫°y hai goroutines, minh h·ªça vi·ªác s·ª≠ d·ª•ng goroutines gi√∫p tƒÉng t·ªëc x·ª≠ l√Ω so v·ªõi ch·∫°y tu·∫ßn t·ª±. Code s·∫Ω t√≠nh to√°n hai t√°c v·ª• n·∫∑ng (v√≠ d·ª•: t√≠nh t·ªïng b√¨nh ph∆∞∆°ng c·ªßa c√°c s·ªë l·ªõn) v√† in th·ªùi gian th·ª±c thi khi ch·∫°y v·ªõi goroutines v√† kh√¥ng d√πng goroutines. M√¨nh s·∫Ω ƒë·∫£m b·∫£o code h·ª£p l√Ω v√† d·ªÖ hi·ªÉu, k√®m v√≠ d·ª• th·ª±c t·∫ø ƒë·ªÉ th·∫•y ƒë∆∞·ª£c l·ª£i √≠ch c·ªßa concurrency.

### √ù t∆∞·ªüng
- **T√°c v·ª•**: T√≠nh t·ªïng b√¨nh ph∆∞∆°ng c·ªßa c√°c s·ªë trong hai m·∫£ng l·ªõn (m·ªói m·∫£ng c√≥ nhi·ªÅu s·ªë ƒë·ªÉ t·∫°o ƒë·ªô tr·ªÖ r√µ r·ªát).
- **So s√°nh**:
  - **Kh√¥ng d√πng goroutines**: T√≠nh tu·∫ßn t·ª± t·ª´ng m·∫£ng.
  - **D√πng goroutines**: T√≠nh ƒë·ªìng th·ªùi hai m·∫£ng, d√πng `wg.Add(2)` ƒë·ªÉ ƒë·ª£i c·∫£ hai goroutines ho√†n th√†nh.
- **ƒêo th·ªùi gian**: S·ª≠ d·ª•ng `time.Now()` v√† `time.Since()` ƒë·ªÉ ƒëo th·ªùi gian th·ª±c thi c·ªßa c·∫£ hai c√°ch.

---

```go
package main

import (
	"fmt"
	"sync"
	"time"
)

// computeSumOfSquares calculates the sum of squares for a given slice of numbers
func computeSumOfSquares(numbers []int, name string) int64 {
	var sum int64
	for _, num := range numbers {
		sum += int64(num) * int64(num)
	}
	fmt.Printf("%s completed, sum of squares: %d\n", name, sum)
	return sum
}

func main() {
	// Create two large slices of numbers for computation
	numbers1 := make([]int, 1000000)
	numbers2 := make([]int, 1000000)
	for i := range numbers1 {
		numbers1[i] = i
		numbers2[i] = i + 1
	}

	// ---- Sequential Execution (No Goroutines) ----
	fmt.Println("Running sequentially (no goroutines)...")
	start := time.Now()

	computeSumOfSquares(numbers1, "Task 1")
	computeSumOfSquares(numbers2, "Task 2")

	sequentialDuration := time.Since(start)
	fmt.Printf("Sequential execution took: %v\n\n", sequentialDuration)

	// ---- Concurrent Execution (With Goroutines) ----
	fmt.Println("Running concurrently (with goroutines)...")
	var wg sync.WaitGroup
	start = time.Now()

	wg.Add(2) // Wait for 2 goroutines

	// Run Task 1 in a goroutine
	go func() {
		computeSumOfSquares(numbers1, "Task 1 (goroutine)")
		wg.Done()
	}()

	// Run Task 2 in a goroutine
	go func() {
		computeSumOfSquares(numbers2, "Task 2 (goroutine)")
		wg.Done()
	}()

	wg.Wait() // Wait for both goroutines to finish
	concurrentDuration := time.Since(start)
	fmt.Printf("Concurrent execution took: %v\n", concurrentDuration)

	// Compare the durations
	fmt.Printf("\nTime saved with goroutines: %v\n", sequentialDuration-concurrentDuration)
}
```

---

### Gi·∫£i th√≠ch ƒëo·∫°n code

#### 1. **√ù nghƒ©a c·ªßa code**
- **T√°c v·ª• n·∫∑ng**: H√†m `computeSumOfSquares` t√≠nh t·ªïng b√¨nh ph∆∞∆°ng c·ªßa c√°c s·ªë trong m·ªôt m·∫£ng l·ªõn (1 tri·ªáu s·ªë). ƒê√¢y l√† t√°c v·ª• CPU-bound, ph√π h·ª£p ƒë·ªÉ minh h·ªça l·ª£i √≠ch c·ªßa concurrency tr√™n m√°y ƒëa l√µi.
- **Ch·∫°y tu·∫ßn t·ª±**:
  - T√≠nh to√°n cho `numbers1`, sau ƒë√≥ t√≠nh cho `numbers2`.
  - Th·ªùi gian th·ª±c thi l√† t·ªïng th·ªùi gian c·ªßa c·∫£ hai t√°c v·ª•.
- **Ch·∫°y ƒë·ªìng th·ªùi**:
  - D√πng hai goroutines ƒë·ªÉ t√≠nh to√°n `numbers1` v√† `numbers2` c√πng l√∫c.
  - `wg.Add(2)` b√°o r·∫±ng c√≥ 2 goroutines c·∫ßn ƒë·ª£i.
  - `wg.Wait()` ƒë·∫£m b·∫£o ch∆∞∆°ng tr√¨nh ƒë·ª£i c·∫£ hai goroutines ho√†n th√†nh.
- **So s√°nh th·ªùi gian**:
  - In th·ªùi gian th·ª±c thi c·ªßa c·∫£ hai c√°ch v√† t√≠nh th·ªùi gian ti·∫øt ki·ªám ƒë∆∞·ª£c khi d√πng goroutines.

#### 2. **T·∫°i sao d√πng goroutines nhanh h∆°n?**
- Tr√™n m√°y c√≥ nhi·ªÅu CPU (ki·ªÉm tra b·∫±ng `runtime.NumCPU()`), Go scheduler c√≥ th·ªÉ ph√¢n b·ªï hai goroutines ƒë·ªÉ ch·∫°y song song tr√™n c√°c CPU kh√°c nhau.
- V·ªõi hai t√°c v·ª• n·∫∑ng nh∆∞ t√≠nh t·ªïng b√¨nh ph∆∞∆°ng, ch·∫°y ƒë·ªìng th·ªùi s·∫Ω g·∫ßn nh∆∞ gi·∫£m th·ªùi gian th·ª±c thi xu·ªëng m·ªôt n·ª≠a (trong ƒëi·ªÅu ki·ªán l√Ω t∆∞·ªüng, khi c√≥ √≠t nh·∫•t 2 CPU).

#### 3. **Output m·∫´u**
Gi·∫£ s·ª≠ ch·∫°y tr√™n m√°y c√≥ 4 CPU, output c√≥ th·ªÉ tr√¥ng nh∆∞ sau:

```
Running sequentially (no goroutines)...
Task 1 completed, sum of squares: 333333833333500000
Task 2 completed, sum of squares: 333334833334500000
Sequential execution took: 1.234567s

Running concurrently (with goroutines)...
Task 1 (goroutine) completed, sum of squares: 333333833333500000
Task 2 (goroutine) completed, sum of squares: 333334833334500000
Concurrent execution took: 0.678901s

Time saved with goroutines: 0.555666s
```

- **L∆∞u √Ω**: Th·ª© t·ª± output c·ªßa `Task 1 (goroutine)` v√† `Task 2 (goroutine)` c√≥ th·ªÉ thay ƒë·ªïi do t√≠nh ch·∫•t kh√¥ng x√°c ƒë·ªãnh c·ªßa concurrency. Th·ªùi gian th·ª±c thi c·ª• th·ªÉ ph·ª• thu·ªôc v√†o ph·∫ßn c·ª©ng v√† t·∫£i h·ªá th·ªëng.

#### 4. **C√°c ƒëi·ªÉm n·ªïi b·∫≠t**
- **`wg.Add(2)`**: B√°o r·∫±ng c√≥ 2 goroutines c·∫ßn ƒë·ª£i. M·ªói goroutine g·ªçi `wg.Done()` khi ho√†n th√†nh, gi·∫£m b·ªô ƒë·∫øm WaitGroup. Khi b·ªô ƒë·∫øm v·ªÅ 0, `wg.Wait()` cho ph√©p ch∆∞∆°ng tr√¨nh ti·∫øp t·ª•c.
- **Concurrency hi·ªáu qu·∫£**: T√°c v·ª• t√≠nh to√°n n·∫∑ng ƒë∆∞·ª£c chia ra hai goroutines, t·∫≠n d·ª•ng ƒëa l√µi CPU ƒë·ªÉ gi·∫£m th·ªùi gian.
- **ƒêo th·ªùi gian**: S·ª≠ d·ª•ng `time.Since` ƒë·ªÉ ƒëo ch√≠nh x√°c th·ªùi gian th·ª±c thi, gi√∫p th·∫•y r√µ l·ª£i √≠ch c·ªßa goroutines.

#### 5. **√Ånh x·∫° th·ª±c t·∫ø**
T∆∞∆°ng t·ª± v√≠ d·ª• nh√† h√†ng ·ªü c√¢u h·ªèi tr∆∞·ªõc:
- Ch·∫°y tu·∫ßn t·ª±: M·ªôt ƒë·∫ßu b·∫øp l√†m m√≥n s√∫p, xong r·ªìi m·ªõi l√†m m√≥n salad (ch·∫≠m).
- Ch·∫°y ƒë·ªìng th·ªùi: Hai ƒë·∫ßu b·∫øp l√†m m√≥n s√∫p v√† salad c√πng l√∫c, t·ªïng th·ªùi gian gi·∫£m ƒë√°ng k·ªÉ.
- `wg.Add(2)`: Qu·∫£n l√Ω ghi v√†o danh s√°ch r·∫±ng c·∫£ m√≥n s√∫p v√† salad c·∫ßn ho√†n th√†nh.
- `wg.Wait()`: Qu·∫£n l√Ω ƒë·ª£i c·∫£ hai ƒë·∫ßu b·∫øp b√°o c√°o xong tr∆∞·ªõc khi ƒë√≥ng c·ª≠a.

#### 6. **L·ª£i √≠ch c·ªßa code n√†y**
- **H·ª£p l√Ω**: T√°c v·ª• t√≠nh t·ªïng b√¨nh ph∆∞∆°ng l√† m·ªôt v√≠ d·ª• th·ª±c t·∫ø, t∆∞∆°ng t·ª± c√°c t√°c v·ª• x·ª≠ l√Ω d·ªØ li·ªáu l·ªõn (nh∆∞ trong machine learning, x·ª≠ l√Ω h√¨nh ·∫£nh).
- **Minh h·ªça r√µ r√†ng**: So s√°nh th·ªùi gian th·ª±c thi gi√∫p th·∫•y ƒë∆∞·ª£c l·ª£i √≠ch c·ªßa concurrency.
- **D·ªÖ m·ªü r·ªông**: C√≥ th·ªÉ th√™m nhi·ªÅu goroutines (v·ªõi `wg.Add(n)`) ƒë·ªÉ x·ª≠ l√Ω nhi·ªÅu m·∫£ng h∆°n.

---

### G·ª£i √Ω n·∫øu mu·ªën th·ª≠ th√™m
- **TƒÉng s·ªë l∆∞·ª£ng goroutines**: Th√™m m·ªôt m·∫£ng th·ª© ba v√† d√πng `wg.Add(3)`.
- **Ki·ªÉm tra CPU**: Th√™m `fmt.Println("NumCPU:", runtime.NumCPU())` ƒë·ªÉ xem m√°y c·ªßa b·∫°n c√≥ bao nhi√™u CPU, ·∫£nh h∆∞·ªüng ƒë·∫øn hi·ªáu su·∫•t concurrency.
- **TƒÉng ƒë·ªô n·∫∑ng c·ªßa t√°c v·ª•**: TƒÉng k√≠ch th∆∞·ªõc m·∫£ng (v√≠ d·ª•: 10 tri·ªáu s·ªë) ƒë·ªÉ th·∫•y r√µ h∆°n s·ª± kh√°c bi·ªát v·ªÅ th·ªùi gian.

N·∫øu b·∫°n mu·ªën m√¨nh ƒëi·ªÅu ch·ªânh code ho·∫∑c gi·∫£i th√≠ch th√™m ph·∫ßn n√†o, c·ª© n√≥i nh√©, bro! üòé