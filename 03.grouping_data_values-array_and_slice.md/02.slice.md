### Theory
- Built on top of an array
- holds values of the same type
- changes in size
- has a length and a capacity


### Example #1:
```go
package main

import (
	"fmt"
	
)

func main() {
	s1 := []string{"apple", "banana", "cherry"}
	fmt.Println("Original slice:", s1)
	fmt.Println("Slice length:", len(s1))
	fmt.Println("Slice capacity:", cap(s1))
	fmt.Printf("Type of slice: %T\n", s1)
	// For loop
	for i, v := range s1 {
		fmt.Printf("Index: %d, Value: %s\n", i, v)
	}
}
```

Output:
```
Original slice: [apple banana cherry]
Slice length: 3
Slice capacity: 3
Type of slice: []string
Index: 0, Value: apple
Index: 1, Value: banana
Index: 2, Value: cherry
```

### Example #2: 
```go
package main

import (
	"fmt"
	
)

func main() {
	s1 := []string{"apple", "banana", "cherry"}

	// For loop, don't show index with blank identifier
	for _, v := range s1 {
		fmt.Printf("Value: %s\n", v)
	}
	fmt.Println("-----------------")
	// accessing the index and value
	fmt.Println(s1[0]) // apple
	fmt.Println(s1[1]) // banana
	fmt.Println(s1[2]) // cherry
	fmt.Println("-----------------")
	// Accessing with for loop 2
	for i := 0; i < len(s1); i++ {
		fmt.Println("Value with style: ", s1[i])
	}
}
```

Output:
```
Value: apple
Value: banana
Value: cherry
-----------------
apple
banana
cherry
-----------------
Value with style:  apple
Value with style:  banana
Value with style:  cherry
```